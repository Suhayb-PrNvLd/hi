<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <title>Ping Pong — Simple Game</title>
  <style>
    :root{ --bg:#0b1220; --panel:#0f1724; --accent:#10b981; --muted:#94a3b8; }
    html,body{height:100%;margin:0;font-family:Inter,system-ui,Segoe UI,Roboto,Arial;background:linear-gradient(180deg,#071029 0%,var(--bg) 100%);color:#fff}
    .wrap{min-height:100%;display:flex;align-items:center;justify-content:center;padding:24px}
    .card{background:linear-gradient(180deg,rgba(255,255,255,0.02),rgba(255,255,255,0.01));padding:18px;border-radius:12px;box-shadow:0 8px 30px rgba(2,6,23,0.6);max-width:900px;width:100%;}
    h1{margin:0 0 10px;font-size:18px;color:var(--muted)}
    .meta{display:flex;gap:12px;align-items:center;margin-bottom:10px}
    canvas{display:block;background:linear-gradient(180deg,#021124 0%,#07172a 100%);border-radius:8px;width:100%;height:480px}
    .controls{display:flex;gap:8px;align-items:center;margin-top:10px}
    button{background:var(--accent);border:none;color:#04201a;padding:8px 12px;border-radius:8px;cursor:pointer;font-weight:600}
    .muted{color:var(--muted);font-size:13px}
    .status{margin-left:12px;color:#93c5fd;font-weight:600}
  </style>
</head>
<body>
  <div class="wrap">
    <div class="card">
      <h1>Ping Pong — Simple Game</h1>
      <div class="meta">
        <div class="muted">Player: W/S &nbsp;|&nbsp; AI or 2-player: Arrow Up/Down</div>
        <div style="margin-left:auto" class="muted">First to 7 wins</div>
      </div>
      <canvas id="c"></canvas>
      <div class="controls">
        <button id="start">Start / Restart</button>
        <button id="toggleAI">Toggle AI</button>
        <div class="status" id="timer">Time: 05:00</div>
        <div style="margin-left:auto" id="score" class="muted">0 — 0</div>
      </div>
    </div>
  </div>

  <script>
    // Pong with sudden death and speed-up on bounces
    const canvas = document.getElementById('c');
    const ctx = canvas.getContext('2d');

    let W = 900, H = 480;
    function resize(){
      canvas.width = Math.min(window.innerWidth - 100, W);
      canvas.height = Math.min(480, window.innerHeight - 150);
    }
    window.addEventListener('resize', resize);
    resize();

    const PADDLE_W = 12, PADDLE_H = 84;
    const BALL_R = 8;
    let left = {x: 24, y: H/2 - PADDLE_H/2, vy:0, score:0};
    let right = {x: W - 24 - PADDLE_W, y: H/2 - PADDLE_H/2, vy:0, score:0};
    let ball = {x: W/2, y: H/2, vx: 220, vy: 80, r: BALL_R};
    let ai = true;
    let running = false;
    const SCORE_TO_WIN = 7;

    // Sudden death settings
    const SUDDEN_DEATH_SECONDS = 300; // 5 minutes
    let startTimestamp = null;
    let suddenDeath = false;
    const timerEl = document.getElementById('timer');

    const keys = {};
    window.addEventListener('keydown', (e)=>{ keys[e.key] = true; });
    window.addEventListener('keyup', (e)=>{ keys[e.key] = false; });

    function resetBall(direction){
      ball.x = W/2; ball.y = H/2;
      const speed = 200 + Math.min(400, (left.score + right.score) * 12);
      const angle = (Math.random()*Math.PI/3) - Math.PI/6;
      const dir = direction || (Math.random() < 0.5 ? -1 : 1);
      const vx = speed * Math.cos(angle) * dir;
      const vy = speed * Math.sin(angle);
      ball.vx = vx; ball.vy = vy;
    }

    function resetGame(){
      left.y = H/2 - PADDLE_H/2; right.y = H/2 - PADDLE_H/2; left.score = 0; right.score = 0; updateScore();
      suddenDeath = false; startTimestamp = null; updateTimerDisplay(SUDDEN_DEATH_SECONDS);
      resetBall(Math.random() < 0.5 ? -1 : 1);
    }

    function draw(){
      ctx.clearRect(0,0,canvas.width,canvas.height);
      ctx.save();
      ctx.scale(canvas.width / W, canvas.height / H);
      ctx.fillStyle = 'rgba(255,255,255,0.06)';
      for(let i=10;i<H;i+=24) ctx.fillRect(W/2 -1, i, 2, 14);
      ctx.fillStyle = '#a3e635';
      roundRect(ctx, left.x, left.y, PADDLE_W, PADDLE_H, 6);
      ctx.fillStyle = '#60a5fa';
      roundRect(ctx, right.x, right.y, PADDLE_W, PADDLE_H, 6);
      ctx.fillStyle = '#f97316';
      ctx.beginPath(); ctx.arc(ball.x, ball.y, ball.r, 0, Math.PI*2); ctx.fill();
      ctx.restore();
    }

    function roundRect(ctx, x, y, w, h, r){
      ctx.beginPath();
      ctx.moveTo(x+r, y);
      ctx.arcTo(x+w, y, x+w, y+h, r);
      ctx.arcTo(x+w, y+h, x, y+h, r);
      ctx.arcTo(x, y+h, x, y, r);
      ctx.arcTo(x, y, x+w, y, r);
      ctx.closePath();
      ctx.fill();
    }

    function clamp(v,a,b){return Math.max(a, Math.min(b, v));}

    function circleRectCollide(c, r){
      const rx = r.x, ry = r.y, rw = PADDLE_W, rh = PADDLE_H;
      const closestX = clamp(c.x, rx, rx+rw);
      const closestY = clamp(c.y, ry, ry+rh);
      const dx = c.x - closestX; const dy = c.y - closestY;
      return (dx*dx + dy*dy) <= (c.r * c.r);
    }

    // speed clamp
    function clampSpeed(){
      const max = 1200;
      const mag = Math.hypot(ball.vx, ball.vy);
      if(mag > max){
        const f = max / mag;
        ball.vx *= f; ball.vy *= f;
      }
    }

    // Timer display
    function updateTimerDisplay(secondsLeft){
      if(suddenDeath){ timerEl.textContent = 'Sudden Death — Next score wins!'; timerEl.style.color = '#fb7185'; return; }
      const m = Math.floor(secondsLeft/60); const s = Math.floor(secondsLeft%60);
      timerEl.textContent = `Time: ${String(m).padStart(2,'0')}:${String(s).padStart(2,'0')}`;
      timerEl.style.color = '#93c5fd';
    }

    let last = performance.now();
    function step(now){
      const dt = Math.min(0.03, (now - last)/1000); last = now;
      if(running){
        // initialize timer
        if(startTimestamp === null) startTimestamp = now;
        const elapsed = (now - startTimestamp) / 1000;
        if(!suddenDeath){
          const remaining = Math.max(0, SUDDEN_DEATH_SECONDS - elapsed);
          updateTimerDisplay(remaining);
          if(elapsed >= SUDDEN_DEATH_SECONDS){
            suddenDeath = true;
            updateTimerDisplay(0);
          }
        }

        const speed = 320;
        if(keys['w'] || keys['W']) left.y -= speed*dt;
        if(keys['s'] || keys['S']) left.y += speed*dt;
        if(!ai){
          if(keys['ArrowUp']) right.y -= speed*dt;
          if(keys['ArrowDown']) right.y += speed*dt;
        } else {
          const center = right.y + PADDLE_H/2;
          const diff = ball.y - center;
          const aiSpeed = 260;
          right.y += Math.max(Math.min(diff*2*dt, aiSpeed*dt), -aiSpeed*dt);
        }
        left.y = clamp(left.y, 0, H - PADDLE_H);
        right.y = clamp(right.y, 0, H - PADDLE_H);

        ball.x += ball.vx * dt; ball.y += ball.vy * dt;

        // top/bottom bounce -> increase speed slightly
        if(ball.y - ball.r < 0){ ball.y = ball.r; ball.vy = -ball.vy; ball.vx *= 1.02; ball.vy *= 1.02; clampSpeed(); }
        if(ball.y + ball.r > H){ ball.y = H - ball.r; ball.vy = -ball.vy; ball.vx *= 1.02; ball.vy *= 1.02; clampSpeed(); }

        // paddle collisions -> larger speed-up and angle change
        if(circleRectCollide(ball, left)){
          ball.x = left.x + PADDLE_W + ball.r;
          ball.vx = Math.abs(ball.vx) * 1.06; // slightly bigger bump
          const n = (ball.y - (left.y + PADDLE_H/2)) / (PADDLE_H/2);
          ball.vy += n * 220;
          clampSpeed();
        }
        if(circleRectCollide(ball, right)){ 
          ball.x = right.x - ball.r;
          ball.vx = -Math.abs(ball.vx) * 1.06;
          const n = (ball.y - (right.y + PADDLE_H/2)) / (PADDLE_H/2);
          ball.vy += n * 220;
          clampSpeed();
        }

        // Score handling
        if(ball.x < -40){
          // right scored
          if(suddenDeath){ right.score += 1; updateScore(); announceWinner('Right player'); }
          else { right.score += 1; updateScore(); checkWin(); resetBall(1); }
        }
        if(ball.x > W + 40){
          if(suddenDeath){ left.score += 1; updateScore(); announceWinner('Left player'); }
          else { left.score += 1; updateScore(); checkWin(); resetBall(-1); }
        }
      }
      draw();
      requestAnimationFrame(step);
    }

    function announceWinner(name){
      running = false;
      setTimeout(()=>alert(name + ' wins!'), 60);
      startTimestamp = null;
    }

    function checkWin(){
      if(left.score >= SCORE_TO_WIN || right.score >= SCORE_TO_WIN){
        running = false;
        const winner = left.score > right.score ? 'Left player' : 'Right player';
        setTimeout(()=>alert(winner + ' wins!'), 60);
        startTimestamp = null;
      }
    }

    function updateScore(){ document.getElementById('score').textContent = left.score + ' — ' + right.score; }

    document.getElementById('start').addEventListener('click', ()=>{ running = true; resetGame(); startTimestamp = performance.now(); });
    document.getElementById('toggleAI').addEventListener('click', ()=>{ ai = !ai; document.getElementById('toggleAI').textContent = ai ? 'Toggle AI (AI)' : 'Toggle AI (2P)'; });

    resetGame(); running = false; requestAnimationFrame(step);
  </script>
</body>
</html>